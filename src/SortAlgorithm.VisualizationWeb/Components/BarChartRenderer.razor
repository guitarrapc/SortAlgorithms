@using SortAlgorithm.VisualizationWeb.Models
@using SortAlgorithm.VisualizationWeb.Services

<div class="bar-chart-container @(State?.PlaybackState == PlaybackState.Playing ? "playing" : "")" 
     @onclick="OnCanvasClick" 
     style="position: relative; width: 100%; height: 100%;">
    
    @if (State != null && State.MainArray.Length > 0)
    {
        var arrayLength = State.MainArray.Length;
        var minBarWidth = 1.0; // æœ€å°ãƒãƒ¼å¹…ï¼ˆpxï¼‰
        var baseWidth = 1200; // ãƒ™ãƒ¼ã‚¹å¹…
        var baseHeight = 600; // ãƒ™ãƒ¼ã‚¹é«˜ã•ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã®åŸºæº–ï¼‰
        var requiredWidth = Math.Max(baseWidth, (int)(arrayLength * minBarWidth));
        var barWidth = (double)requiredWidth / arrayLength;
        
        // æœ€å¤§å€¤ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ Max()ã‚’å‘¼ã¶ã®ã¯é‡ã„ï¼‰
        var maxValue = GetOrCacheMaxValue(State.MainArray);
        
        <svg width="100%" height="100%" viewBox="0 0 @requiredWidth @baseHeight" preserveAspectRatio="xMidYMax meet" style="display: block;">
            <g shape-rendering="crispEdges">
                @for (int i = 0; i < arrayLength; i++)
                {
                    var value = State.MainArray[i];
                    var barHeight = (value / (double)maxValue) * (baseHeight - 20);
                    var x = i * barWidth;
                    var y = baseHeight - barHeight;
                    var color = GetBarColor(i);
                    
                    <rect @key="i"
                          x="@x" 
                          y="@y" 
                          width="@barWidth" 
                          height="@barHeight"
                          fill="@color"
                          stroke="none" />
                }
            </g>
        </svg>
    }
    else
    {
        <div style="text-align: center; color: #999;">
            <p style="font-size: 2rem;">ğŸ“Š</p>
            <p>Click "Generate & Sort" to start visualization</p>
        </div>
    }
</div>

@code {
    [Parameter]
    public VisualizationState? State { get; set; }
    
    [Parameter]
    public EventCallback OnClick { get; set; }
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç”¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    private int _cachedMaxValue;
    private int _lastArrayHashCode;
    
    /// <summary>
    /// æœ€å¤§å€¤ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦è¿”ã™ï¼ˆé…åˆ—ã®å†…å®¹ãŒå¤‰ã‚ã£ãŸæ™‚ã ã‘å†è¨ˆç®—ï¼‰
    /// </summary>
    private int GetOrCacheMaxValue(int[] array)
    {
        var currentHashCode = array.GetHashCode();
        if (currentHashCode != _lastArrayHashCode || _cachedMaxValue == 0)
        {
            _cachedMaxValue = array.Max();
            _lastArrayHashCode = currentHashCode;
        }
        return _cachedMaxValue;
    }
    
    private string GetBarColor(int index)
    {
        if (State == null) return "#3B82F6";
        
        // ã‚½ãƒ¼ãƒˆå®Œäº†æ™‚ã¯ç·‘è‰²ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        if (State.IsSortCompleted) return "#10B981"; // Green - Sorted
        
        if (State.SwapIndices.Contains(index)) return "#EF4444"; // Red - Swap
        if (State.CompareIndices.Contains(index)) return "#A855F7"; // Purple - Compare
        if (State.WriteIndices.Contains(index)) return "#F97316"; // Orange - Write
        if (State.ReadIndices.Contains(index)) return "#FBBF24"; // Yellow - Read
        
        return "#3B82F6"; // Blue - Normal
    }
    
    private async Task OnCanvasClick()
    {
        await OnClick.InvokeAsync();
    }
}


