@using SortAlgorithm.VisualizationWeb.Models
@using SortAlgorithm.VisualizationWeb.Services
@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject DebugSettings DebugSettings
@implements IAsyncDisposable

<div class="bar-chart-container @(State?.PlaybackState == PlaybackState.Playing ? "playing" : "")"
     @onclick="OnCanvasClick"
     style="position: relative; width: 100%; height: 100%;">

    @if (State != null && State.MainArray.Length > 0)
    {
        <canvas id="@_canvasId" style="width: 100%; height: 100%; display: block;"></canvas>
    }
    else
    {
        <div style="text-align: center; color: #999; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center;">
            <p style="font-size: 2rem;">ğŸ“Š</p>
            <p>Click "Generate & Sort" to start visualization</p>
        </div>
    }
</div>

@code {
    [Parameter]
    public VisualizationState? State { get; set; }

    [Parameter]
    public EventCallback OnClick { get; set; }

    [Parameter]
    public int GridColumnCount { get; set; } = 1;

    private string _canvasId = $"sortCanvas_{Guid.NewGuid():N}";
    private bool _isInitialized = false;
    private bool _previousHasData = false;
    private int _previousGridColumnCount = 0;
    private int _lastSortVersion = -1; // JS å´é…åˆ—ãŒåˆæœŸåŒ–æ¸ˆã¿ã‹ã‚’è¿½è·¡ã™ã‚‹

    // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é »åº¦è¨ˆæ¸¬
    private int _renderCount = 0;
    private DateTime _lastFpsLog = DateTime.UtcNow;

    protected override bool ShouldRender()
    {
        // Canvas ã¯ JS å´ã§æç”»ã™ã‚‹ãŸã‚ Blazor ã® DOM å·®åˆ†ã¯ä¸è¦
        // canvas è¦ç´ ã®è¡¨ç¤º/éè¡¨ç¤ºãŒå¤‰ã‚ã‚‹ã¨ãã€ã¾ãŸã¯æœªåˆæœŸåŒ–ã®ã¨ãã®ã¿å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
        var hasData = State?.MainArray.Length > 0;
        var shouldRender = _previousHasData != hasData || !_isInitialized;
        _previousHasData = hasData;
        return shouldRender;
    }

    protected override async Task OnParametersSetAsync()
    {
        // ShouldRender() ã‚ˆã‚Šå…ˆã«å‘¼ã°ã‚Œã‚‹ãŸã‚ã€æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã® JS ãƒ‡ãƒ¼ã‚¿è»¢é€ã¯ã“ã“ã§è¡Œã†
        if (!_isInitialized) return;

        // ã‚°ãƒªãƒƒãƒ‰åˆ—æ•°ãŒå¤‰ã‚ã£ãŸå ´åˆã®è¨˜éŒ²ï¼ˆResizeObserver ãŒè‡ªå‹•ãƒªã‚µã‚¤ã‚ºï¼†å†æç”»ï¼‰
        if (_previousGridColumnCount != GridColumnCount)
        {
            DebugSettings.Log($"[CanvasRenderer] Grid column count changed: {_previousGridColumnCount} -> {GridColumnCount} for canvas {_canvasId}");
            _previousGridColumnCount = GridColumnCount;
        }

        // æç”»
        await RenderCanvas();

        // ğŸ” ãƒ‡ãƒãƒƒã‚°ï¼šãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é »åº¦ã‚’ãƒ­ã‚°å‡ºåŠ›
        _renderCount++;
        var now = DateTime.UtcNow;
        var elapsed = (now - _lastFpsLog).TotalSeconds;
        if (elapsed >= 1.0)
        {
            DebugSettings.Log($"[CanvasRenderer] {_canvasId.Substring(0, 12)}... Render FPS: {_renderCount / elapsed:F1}");
            _renderCount = 0;
            _lastFpsLog = now;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯ OnParametersSetAsync ã§ãƒ‡ãƒ¼ã‚¿è»¢é€æ¸ˆã¿ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—
        if (_isInitialized) return;

        // canvas è¦ç´ ãŒ DOM ã«ç¾ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§åˆæœŸåŒ–ã‚’è©¦ã¿ã‚‹
        var success = await JS.InvokeAsync<bool>("canvasRenderer.initialize", _canvasId);
        if (success)
        {
            _isInitialized = true;
            _previousGridColumnCount = GridColumnCount;
            await RenderCanvas();
        }
    }

    private async Task RenderCanvas()
    {
        if (!_isInitialized || State == null || State.MainArray.Length == 0) return;

        try
        {
            if (_lastSortVersion != State.SortVersion)
            {
                // æ–°ã—ã„ã‚½ãƒ¼ãƒˆãŒãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸ â†’ JS å´é…åˆ—ã‚’åˆæœŸåŒ–ï¼ˆå…¨é‡è»¢é€ã¯1å›ã®ã¿ï¼‰
                _lastSortVersion = State.SortVersion;
                await JS.InvokeVoidAsync("canvasRenderer.setArray",
                    _canvasId,
                    State.MainArray,
                    State.BufferArrays,
                    State.CompareIndices,
                    State.SwapIndices,
                    State.ReadIndices,
                    State.WriteIndices,
                    State.IsSortCompleted,
                    State.ShowCompletionHighlight);
            }
            else if (State.MainArrayDelta != null)
            {
                // é€šå¸¸å†ç”Ÿ â†’ å·®åˆ†ã®ã¿è»¢é€ï¼ˆé«˜é€Ÿãƒ‘ã‚¹: æ•°åãƒã‚¤ãƒˆç¨‹åº¦ï¼‰
                await JS.InvokeVoidAsync("canvasRenderer.applyFrame",
                    _canvasId,
                    State.MainArrayDelta,
                    State.BufferArrayDeltas,
                    State.CompareIndices,
                    State.SwapIndices,
                    State.ReadIndices,
                    State.WriteIndices,
                    State.IsSortCompleted,
                    State.ShowCompletionHighlight);
            }
            else
            {
                // å…¨é‡æ›´æ–°ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆã‚·ãƒ¼ã‚¯å¾Œãƒ»ãƒªã‚»ãƒƒãƒˆå¾Œï¼‰
                await JS.InvokeVoidAsync("canvasRenderer.updateData",
                    _canvasId,
                    State.MainArray,
                    State.CompareIndices,
                    State.SwapIndices,
                    State.ReadIndices,
                    State.WriteIndices,
                    State.IsSortCompleted,
                    State.BufferArrays,
                    State.ShowCompletionHighlight);
            }
        }
        catch (Exception ex)
        {
            DebugSettings.Log($"Canvas render error: {ex.Message}");
        }
    }

    private async Task OnCanvasClick()
    {
        await OnClick.InvokeAsync();
    }

    public async ValueTask DisposeAsync()
    {
        DebugSettings.Log($"[CanvasRenderer] DisposeAsync called for canvas: {_canvasId}");

        if (_isInitialized)
        {
            try
            {
                await JS.InvokeVoidAsync("canvasRenderer.dispose", _canvasId);
                DebugSettings.Log($"[CanvasRenderer] Successfully disposed canvas: {_canvasId}");
            }
            catch (Exception ex)
            {
                DebugSettings.Log($"[CanvasRenderer] ERROR disposing canvas {_canvasId}: {ex.Message}");
            }
        }
        else
        {
            DebugSettings.Log($"[CanvasRenderer] Canvas {_canvasId} was not initialized, skipping dispose");
        }
    }
}
