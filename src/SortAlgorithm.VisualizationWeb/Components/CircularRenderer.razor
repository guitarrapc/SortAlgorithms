@using SortAlgorithm.VisualizationWeb.Models
@using SortAlgorithm.VisualizationWeb.Services
@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject DebugSettings DebugSettings
@inject RenderSettings RenderSettings
@implements IAsyncDisposable

<div class="circular-chart-container @(State?.PlaybackState == PlaybackState.Playing ? "playing" : "")"
     @onclick="OnCanvasClick"
     style="position: relative; width: 100%; height: 100%;">

    @if (State != null && State.MainArray.Length > 0)
    {
        <canvas id="@_canvasId" style="width: 100%; height: 100%; display: block;"></canvas>
    }
    else
    {
        <div style="text-align: center; color: #999; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center;">
            <p style="font-size: 2rem;">⭕</p>
            <p>Click "Generate & Sort" to start visualization</p>
        </div>
    }
</div>

@code {
    [Parameter]
    public VisualizationState? State { get; set; }

    [Parameter]
    public EventCallback OnClick { get; set; }

    [Parameter]
    public int GridColumnCount { get; set; } = 1;

    private string _canvasId = $"sortCircularCanvas_{Guid.NewGuid():N}";
    private bool _isInitialized = false;
    private bool _isInitializing = false;
    private bool _previousHasData = false;
    private int _previousGridColumnCount = 0;
    private int _lastSortVersion = -1; // JS 側配列が初期化済みかを追跡する

    protected override void OnInitialized()
    {
        RenderSettings.OnChanged += OnRenderSettingsChanged;
    }

    // レンダラー設定変更時: 旧 canvas を破棄し、新しい canvas ID で再初期化する
    private void OnRenderSettingsChanged()
    {
        InvokeAsync(async () =>
        {
            var oldCanvasId = _canvasId;
            var wasInitialized = _isInitialized;

            // 先に状態をリセットしてから DOM を更新
            _canvasId = $"sortCircularCanvas_{Guid.NewGuid():N}";
            _isInitialized = false;
            _lastSortVersion = -1;
            StateHasChanged(); // 新しい canvas 要素を DOM に作成

            // 古い canvas の破棄は DOM 更新後に実行
            if (wasInitialized)
            {
                try { await JS.InvokeVoidAsync("circularCanvasRenderer.dispose", oldCanvasId); } catch { }
            }
        });
    }

    protected override bool ShouldRender()
    {
        // Canvas は JS 側で描画するため Blazor の DOM 差分は不要
        // canvas 要素の表示/非表示が変わるとき、または未初期化のときのみ再レンダリング
        var hasData = State?.MainArray.Length > 0;
        var shouldRender = _previousHasData != hasData || !_isInitialized;
        _previousHasData = hasData;
        return shouldRender;
    }

    protected override async Task OnParametersSetAsync()
    {
        // ShouldRender() より先に呼ばれるため、毎フレームの JS データ転送はここで行う
        if (!_isInitialized) return;

        // グリッド列数が変わった場合の記録（ResizeObserver が自動リサイズ＆再描画）
        if (_previousGridColumnCount != GridColumnCount)
        {
            DebugSettings.Log($"[CircularRenderer] Grid column count changed: {_previousGridColumnCount} -> {GridColumnCount} for canvas {_canvasId}");
            _previousGridColumnCount = GridColumnCount;
        }

        await RenderCanvas();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // 初期化済み、または初期化中の場合はスキップ（二重初期化防止）
        if (_isInitialized || _isInitializing) return;
        _isInitializing = true;
        var targetCanvasId = _canvasId; // await 中に _canvasId が変わる場合に備えてキャプチャ

        try
        {
            // canvas 要素が DOM に現れたタイミングで初期化を試みる
            var success = await JS.InvokeAsync<bool>("circularCanvasRenderer.initialize", targetCanvasId, RenderSettings.UseWebGL);
            if (success && _canvasId == targetCanvasId)
            {
                _isInitialized = true;
                _previousGridColumnCount = GridColumnCount;
                await RenderCanvas();
            }
        }
        finally
        {
            _isInitializing = false;
            // 設定変更で canvas が切り替わった場合、新しい canvas の初期化を促す
            if (!_isInitialized)
                StateHasChanged();
        }
    }

    private async Task RenderCanvas()
    {
        if (!_isInitialized || State == null || State.MainArray.Length == 0) return;

        try
        {
            if (_lastSortVersion != State.SortVersion)
            {
                _lastSortVersion = State.SortVersion;
                await JS.InvokeVoidAsync("circularCanvasRenderer.setArray",
                    _canvasId,
                    State.MainArray,
                    State.BufferArrays,
                    State.CompareIndices,
                    State.SwapIndices,
                    State.ReadIndices,
                    State.WriteIndices,
                    State.IsSortCompleted,
                    State.ShowCompletionHighlight);
            }
            else if (State.MainArrayDelta != null)
            {
                await JS.InvokeVoidAsync("circularCanvasRenderer.applyFrame",
                    _canvasId,
                    State.MainArrayDelta,
                    State.BufferArrayDeltas,
                    State.CompareIndices,
                    State.SwapIndices,
                    State.ReadIndices,
                    State.WriteIndices,
                    State.IsSortCompleted,
                    State.ShowCompletionHighlight);
            }
            else
            {
                await JS.InvokeVoidAsync("circularCanvasRenderer.updateData",
                    _canvasId,
                    State.MainArray,
                    State.CompareIndices,
                    State.SwapIndices,
                    State.ReadIndices,
                    State.WriteIndices,
                    State.IsSortCompleted,
                    State.BufferArrays,
                    State.ShowCompletionHighlight);
            }
        }
        catch (Exception ex)
        {
            DebugSettings.Log($"Circular Canvas render error: {ex.Message}");
        }
    }

    private async Task OnCanvasClick()
    {
        await OnClick.InvokeAsync();
    }

    public async ValueTask DisposeAsync()
    {
        RenderSettings.OnChanged -= OnRenderSettingsChanged;
        DebugSettings.Log($"[CircularRenderer] DisposeAsync called for canvas: {_canvasId}");

        if (_isInitialized)
        {
            try
            {
                await JS.InvokeVoidAsync("circularCanvasRenderer.dispose", _canvasId);
                DebugSettings.Log($"[CircularRenderer] Successfully disposed canvas: {_canvasId}");
            }
            catch (Exception ex)
            {
                DebugSettings.Log($"[CircularRenderer] ERROR disposing canvas {_canvasId}: {ex.Message}");
            }
        }
        else
        {
            DebugSettings.Log($"[CircularRenderer] Canvas {_canvasId} was not initialized, skipping dispose");
        }
    }
}
